create extension if not exists "pg_cron" with schema "pg_catalog";

drop extension if exists "pg_net";

create extension if not exists "pg_net" with schema "public";


  create table "public"."commitments" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "week_start_date" date not null,
    "week_end_date" date not null,
    "limit_minutes" integer not null,
    "penalty_per_minute_cents" integer not null,
    "apps_to_limit" jsonb,
    "status" text not null default 'pending'::text,
    "monitoring_status" text not null default 'ok'::text,
    "monitoring_revoked_at" timestamp with time zone,
    "autocharge_consent_at" timestamp with time zone,
    "max_charge_cents" integer not null,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."commitments" enable row level security;


  create table "public"."daily_usage" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "commitment_id" uuid not null,
    "date" date not null,
    "used_minutes" integer not null,
    "limit_minutes" integer not null,
    "exceeded_minutes" integer not null,
    "penalty_cents" integer not null,
    "is_estimated" boolean not null default false,
    "reported_at" timestamp with time zone not null default now(),
    "source" text not null default 'ios_app'::text
      );


alter table "public"."daily_usage" enable row level security;


  create table "public"."payments" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "week_start_date" date not null,
    "amount_cents" integer not null,
    "currency" text not null default 'usd'::text,
    "stripe_payment_intent_id" text,
    "stripe_charge_id" text,
    "status" text not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."payments" enable row level security;


  create table "public"."usage_adjustments" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "commitment_id" uuid not null,
    "date" date,
    "minutes_delta" integer not null,
    "reason" text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."usage_adjustments" enable row level security;


  create table "public"."user_week_penalties" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "week_start_date" date not null,
    "total_penalty_cents" integer not null default 0,
    "status" text not null default 'pending'::text,
    "last_updated" timestamp with time zone not null default now()
      );


alter table "public"."user_week_penalties" enable row level security;


  create table "public"."users" (
    "id" uuid not null,
    "email" text,
    "stripe_customer_id" text,
    "has_active_payment_method" boolean not null default false,
    "is_test_user" boolean not null default false,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."users" enable row level security;


  create table "public"."weekly_pools" (
    "id" uuid not null default gen_random_uuid(),
    "week_start_date" date not null,
    "week_end_date" date not null,
    "total_penalty_cents" integer not null default 0,
    "status" text,
    "closed_at" timestamp with time zone,
    "instagram_post_url" text,
    "instagram_image_url" text,
    "notes" text
      );


alter table "public"."weekly_pools" enable row level security;

CREATE UNIQUE INDEX commitments_pkey ON public.commitments USING btree (id);

CREATE UNIQUE INDEX daily_usage_pkey ON public.daily_usage USING btree (id);

CREATE UNIQUE INDEX daily_usage_user_date_commitment_unique ON public.daily_usage USING btree (user_id, date, commitment_id);

CREATE INDEX idx_commitments_status ON public.commitments USING btree (status);

CREATE INDEX idx_commitments_user_id ON public.commitments USING btree (user_id);

CREATE INDEX idx_commitments_week_end_date ON public.commitments USING btree (week_end_date);

CREATE INDEX idx_daily_usage_commitment_id ON public.daily_usage USING btree (commitment_id);

CREATE INDEX idx_daily_usage_date ON public.daily_usage USING btree (date);

CREATE INDEX idx_daily_usage_user_id ON public.daily_usage USING btree (user_id);

CREATE INDEX idx_payments_status ON public.payments USING btree (status);

CREATE INDEX idx_payments_user_id ON public.payments USING btree (user_id);

CREATE INDEX idx_user_week_penalties_status ON public.user_week_penalties USING btree (status);

CREATE INDEX idx_user_week_penalties_user_id ON public.user_week_penalties USING btree (user_id);

CREATE UNIQUE INDEX payments_pkey ON public.payments USING btree (id);

CREATE UNIQUE INDEX usage_adjustments_pkey ON public.usage_adjustments USING btree (id);

CREATE UNIQUE INDEX user_week_penalties_pkey ON public.user_week_penalties USING btree (id);

CREATE UNIQUE INDEX user_week_penalties_user_week_unique ON public.user_week_penalties USING btree (user_id, week_start_date);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id);

CREATE UNIQUE INDEX weekly_pools_pkey ON public.weekly_pools USING btree (id);

CREATE UNIQUE INDEX weekly_pools_week_start_date_key ON public.weekly_pools USING btree (week_start_date);

alter table "public"."commitments" add constraint "commitments_pkey" PRIMARY KEY using index "commitments_pkey";

alter table "public"."daily_usage" add constraint "daily_usage_pkey" PRIMARY KEY using index "daily_usage_pkey";

alter table "public"."payments" add constraint "payments_pkey" PRIMARY KEY using index "payments_pkey";

alter table "public"."usage_adjustments" add constraint "usage_adjustments_pkey" PRIMARY KEY using index "usage_adjustments_pkey";

alter table "public"."user_week_penalties" add constraint "user_week_penalties_pkey" PRIMARY KEY using index "user_week_penalties_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."weekly_pools" add constraint "weekly_pools_pkey" PRIMARY KEY using index "weekly_pools_pkey";

alter table "public"."commitments" add constraint "commitments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."commitments" validate constraint "commitments_user_id_fkey";

alter table "public"."daily_usage" add constraint "daily_usage_commitment_id_fkey" FOREIGN KEY (commitment_id) REFERENCES public.commitments(id) ON DELETE CASCADE not valid;

alter table "public"."daily_usage" validate constraint "daily_usage_commitment_id_fkey";

alter table "public"."daily_usage" add constraint "daily_usage_user_date_commitment_unique" UNIQUE using index "daily_usage_user_date_commitment_unique";

alter table "public"."daily_usage" add constraint "daily_usage_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."daily_usage" validate constraint "daily_usage_user_id_fkey";

alter table "public"."payments" add constraint "payments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."payments" validate constraint "payments_user_id_fkey";

alter table "public"."payments" add constraint "payments_week_start_date_fkey" FOREIGN KEY (week_start_date) REFERENCES public.weekly_pools(week_start_date) not valid;

alter table "public"."payments" validate constraint "payments_week_start_date_fkey";

alter table "public"."usage_adjustments" add constraint "usage_adjustments_commitment_id_fkey" FOREIGN KEY (commitment_id) REFERENCES public.commitments(id) ON DELETE CASCADE not valid;

alter table "public"."usage_adjustments" validate constraint "usage_adjustments_commitment_id_fkey";

alter table "public"."usage_adjustments" add constraint "usage_adjustments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."usage_adjustments" validate constraint "usage_adjustments_user_id_fkey";

alter table "public"."user_week_penalties" add constraint "user_week_penalties_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_week_penalties" validate constraint "user_week_penalties_user_id_fkey";

alter table "public"."user_week_penalties" add constraint "user_week_penalties_user_week_unique" UNIQUE using index "user_week_penalties_user_week_unique";

alter table "public"."user_week_penalties" add constraint "user_week_penalties_week_start_date_fkey" FOREIGN KEY (week_start_date) REFERENCES public.weekly_pools(week_start_date) not valid;

alter table "public"."user_week_penalties" validate constraint "user_week_penalties_week_start_date_fkey";

alter table "public"."weekly_pools" add constraint "weekly_pools_week_start_date_key" UNIQUE using index "weekly_pools_week_start_date_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.call_weekly_close()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  request_id bigint;
BEGIN
  -- Make HTTP POST request using positional parameters
  -- Format: net.http_post(url, headers, body, timeout_milliseconds)
  SELECT net.http_post(
    'https://YOUR_PROJECT.supabase.co/functions/v1/weekly-close',  -- REPLACE YOUR_PROJECT
    jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer YOUR_SERVICE_ROLE_KEY_HERE'  -- REPLACE YOUR_SERVICE_ROLE_KEY_HERE
    ),
    '{}'::jsonb,
    30000
  ) INTO request_id;
  
  -- Log that request was queued
  RAISE NOTICE 'Weekly close Edge Function called. Request ID: %', request_id;
  
  -- Note: pg_net processes requests asynchronously
  -- The response will be available in net.http_response_queue later
  -- For cron jobs, we just need to trigger the request
  
EXCEPTION
  WHEN OTHERS THEN
    RAISE WARNING 'Error calling weekly-close Edge Function: %', SQLERRM;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.users (id, email, created_at)
  VALUES (NEW.id, NEW.email, NOW())
  ON CONFLICT (id) DO NOTHING;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.rpc_create_commitment(p_deadline_date date, p_limit_minutes integer, p_penalty_per_minute_cents integer, p_apps_to_limit jsonb)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_user_id uuid := auth.uid();
  v_has_pm boolean;
  v_commitment_start_date date;
  v_days_remaining integer;
  v_risk_factor numeric;
  v_max_charge_cents integer;
  v_app_count integer;
  v_commitment_id uuid;
  v_result json;
begin
  -- 1) Must be authenticated
  if v_user_id is null then
    raise exception 'Not authenticated' using errcode = '42501';
  end if;

  -- 2) Check that user has an active payment method
  select u.has_active_payment_method
  into v_has_pm
  from public.users u
  where u.id = v_user_id;

  if coalesce(v_has_pm, false) = false then
    raise exception 'User has no active payment method' using errcode = 'P0001';
  end if;

  -- 3) The commitment starts NOW (when user commits) and ends on the deadline
  v_commitment_start_date := current_date;  -- Commitment starts today

  -- 4) Compute days remaining until deadline (minimum 1)
  v_days_remaining := greatest(1, p_deadline_date - current_date);

  -- 5) Extract app count from JSONB object
  -- p_apps_to_limit is a JSONB object: {"app_bundle_ids": [], "categories": []}
  -- We need to access the nested arrays and sum their lengths
  v_app_count := coalesce(jsonb_array_length(p_apps_to_limit->'app_bundle_ids'), 0)
               + coalesce(jsonb_array_length(p_apps_to_limit->'categories'), 0);

  -- 6) Simple risk factor based on number of apps/categories
  v_risk_factor := 1.0 + 0.1 * v_app_count;

  -- 7) Compute max_charge_cents
  v_max_charge_cents :=
      v_days_remaining
    * p_limit_minutes
    * p_penalty_per_minute_cents
    * v_risk_factor;

  -- Round to integer just in case
  v_max_charge_cents := floor(v_max_charge_cents)::int;

  -- 8) Ensure weekly pool for this week exists
  -- Use the deadline date as the pool identifier
  -- This groups all commitments that end on the same Monday
  insert into public.weekly_pools (
    week_start_date,
    week_end_date,
    total_penalty_cents,
    status
  )
  values (
    p_deadline_date,    -- Use deadline as pool identifier
    p_deadline_date,    -- Same as deadline (pool ends when commitments end)
    0,
    'open'
  )
  on conflict (week_start_date) do nothing;

  -- 9) Insert commitment row and get the ID
  -- IMPORTANT: The column names week_start_date and week_end_date are legacy naming
  --   - week_start_date: Actually stores when the commitment started (current_date, when user commits)
  --   - week_end_date: Actually stores the deadline (p_deadline_date, next Monday before noon)
  -- The commitment starts NOW (current_date) and ends on the deadline
  insert into public.commitments (
    user_id,
    week_start_date,  -- Legacy name: Actually the commitment start date (when user commits)
    week_end_date,    -- Legacy name: Actually the deadline (next Monday before noon)
    limit_minutes,
    penalty_per_minute_cents,
    apps_to_limit,
    status,
    monitoring_status,
    monitoring_revoked_at,
    autocharge_consent_at,
    max_charge_cents,
    created_at
  )
  values (
    v_user_id,
    v_commitment_start_date,  -- Commitment starts NOW (when user commits)
    p_deadline_date,          -- Commitment ends on deadline (next Monday before noon)
    p_limit_minutes,
    p_penalty_per_minute_cents,
    p_apps_to_limit,
    'pending',      -- or 'active' depending on your flow
    'ok',
    null,
    now(),
    v_max_charge_cents,
    now()
  )
  returning id into v_commitment_id;

  -- 10) Fetch the full commitment row and convert to JSON
  select row_to_json(c.*) into v_result
  from public.commitments c
  where c.id = v_commitment_id;

  -- 11) Return JSON result
  return v_result;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.rpc_get_week_status(p_week_start_date date DEFAULT NULL::date)
 RETURNS TABLE(user_total_penalty_cents integer, user_status text, user_max_charge_cents integer, pool_total_penalty_cents integer, pool_status text, pool_instagram_post_url text, pool_instagram_image_url text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_user_id uuid := auth.uid();
  v_week_start_date date;
  v_commitment public.commitments;
  v_user_week_pen public.user_week_penalties;
  v_pool public.weekly_pools;
begin
  -- 1) Must be authenticated
  if v_user_id is null then
    raise exception 'Not authenticated' using errcode = '42501';
  end if;

  -- 2) Determine week_start_date
  if p_week_start_date is not null then
    v_week_start_date := p_week_start_date;
  else
    -- Use current week's Monday as default
    v_week_start_date := date_trunc('week', current_date)::date;
  end if;

  -- 3) Fetch latest commitment for this user & week (if any)
  select c.*
  into v_commitment
  from public.commitments c
  where c.user_id = v_user_id
    and c.week_start_date = v_week_start_date
  order by c.created_at desc
  limit 1;

  -- 4) Fetch user_week_penalties row (if any)
  select uwp.*
  into v_user_week_pen
  from public.user_week_penalties uwp
  where uwp.user_id = v_user_id
    and uwp.week_start_date = v_week_start_date
  limit 1;

  -- 5) Fetch weekly_pools row (if any)
  select wp.*
  into v_pool
  from public.weekly_pools wp
  where wp.week_start_date = v_week_start_date
  limit 1;

  -- 6) Map to return fields with sensible defaults

  user_total_penalty_cents :=
    coalesce(v_user_week_pen.total_penalty_cents, 0);

  user_status :=
    coalesce(v_user_week_pen.status, 'none');  -- 'pending' | 'paid' | 'failed' | 'none'

  user_max_charge_cents :=
    coalesce(v_commitment.max_charge_cents, 0);

  pool_total_penalty_cents :=
    coalesce(v_pool.total_penalty_cents, 0);

  pool_status :=
    coalesce(v_pool.status, 'open');  -- or 'none' if you prefer

  pool_instagram_post_url :=
    v_pool.instagram_post_url;

  pool_instagram_image_url :=
    v_pool.instagram_image_url;

  return;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.rpc_report_usage(p_date date, p_week_start_date date, p_used_minutes integer)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_user_id uuid := auth.uid();
  v_commitment_id uuid;
  v_limit_minutes integer;
  v_penalty_per_minute_cents integer;
  v_exceeded_minutes integer;
  v_penalty_cents integer;
  v_user_week_total_cents integer;
  v_pool_total_cents integer;
  v_result json;
BEGIN
  -- 1) Must be authenticated
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'Not authenticated' USING ERRCODE = '42501';
  END IF;

  -- 2) Find the active commitment for this user and week
  -- FIX: Match by week_end_date (deadline), not week_start_date
  -- Note: week_end_date in commitments table is actually the deadline (next Monday)
  -- So we match where the deadline (week_end_date) equals p_week_start_date
  SELECT 
    c.id,
    c.limit_minutes,
    c.penalty_per_minute_cents
  INTO 
    v_commitment_id,
    v_limit_minutes,
    v_penalty_per_minute_cents
  FROM public.commitments c
  WHERE c.user_id = v_user_id
    AND c.week_end_date = p_week_start_date  -- FIX: Changed from week_start_date to week_end_date
    AND c.status IN ('pending', 'active')
  ORDER BY c.created_at DESC
  LIMIT 1;

  -- 3) Check if commitment exists
  IF v_commitment_id IS NULL THEN
    RAISE EXCEPTION 'No active commitment found for this week' USING ERRCODE = 'P0002';
  END IF;

  -- 4) Calculate exceeded minutes and penalty
  v_exceeded_minutes := GREATEST(0, p_used_minutes - v_limit_minutes);
  v_penalty_cents := v_exceeded_minutes * v_penalty_per_minute_cents;

  -- 5) Upsert into daily_usage
  INSERT INTO public.daily_usage (
    user_id,
    commitment_id,
    date,
    used_minutes,
    limit_minutes,
    exceeded_minutes,
    penalty_cents,
    is_estimated,
    reported_at,
    source
  )
  VALUES (
    v_user_id,
    v_commitment_id,
    p_date,
    p_used_minutes,
    v_limit_minutes,
    v_exceeded_minutes,
    v_penalty_cents,
    false,
    NOW(),
    'ios_app'
  )
  ON CONFLICT (user_id, date, commitment_id)
  DO UPDATE SET
    used_minutes = EXCLUDED.used_minutes,
    limit_minutes = EXCLUDED.limit_minutes,
    exceeded_minutes = EXCLUDED.exceeded_minutes,
    penalty_cents = EXCLUDED.penalty_cents,
    is_estimated = EXCLUDED.is_estimated,
    reported_at = NOW(),
    source = EXCLUDED.source;

  -- 6) Recalculate user_week_penalties
  -- Sum all daily usage for this commitment (from commitment start to deadline)
  SELECT COALESCE(SUM(penalty_cents), 0)
  INTO v_user_week_total_cents
  FROM public.daily_usage
  WHERE user_id = v_user_id
    AND commitment_id = v_commitment_id
    AND date >= (
      SELECT week_start_date  -- Actually the commitment start date
      FROM public.commitments 
      WHERE id = v_commitment_id
    )
    AND date <= (
      SELECT week_end_date  -- Actually the deadline
      FROM public.commitments 
      WHERE id = v_commitment_id
    );

  -- Upsert user_week_penalties
  INSERT INTO public.user_week_penalties (
    user_id,
    week_start_date,  -- Actually stores the deadline
    total_penalty_cents,
    status,
    last_updated
  )
  VALUES (
    v_user_id,
    p_week_start_date,  -- Deadline (next Monday)
    v_user_week_total_cents,
    'pending',
    NOW()
  )
  ON CONFLICT (user_id, week_start_date)
  DO UPDATE SET
    total_penalty_cents = EXCLUDED.total_penalty_cents,
    last_updated = NOW();

  -- 7) Recalculate weekly_pools
  -- FIX: Changed from UPDATE to INSERT ... ON CONFLICT to create if missing
  -- Note: In weekly_pools, week_start_date is the deadline (Monday before noon)
  -- All users with the same deadline share the same pool
  SELECT COALESCE(SUM(total_penalty_cents), 0)
  INTO v_pool_total_cents
  FROM public.user_week_penalties
  WHERE week_start_date = p_week_start_date;

  -- Upsert weekly_pools (creates if doesn't exist, updates if exists)
  INSERT INTO public.weekly_pools (
    week_start_date,  -- Deadline (next Monday) - used as pool identifier
    week_end_date,    -- Same as start (deadline is the pool identifier)
    total_penalty_cents,
    status
  )
  VALUES (
    p_week_start_date,  -- Deadline (next Monday)
    p_week_start_date,  -- Same as start (deadline is the pool identifier)
    v_pool_total_cents,
    'open'
  )
  ON CONFLICT (week_start_date)  -- FIX: Changed from UPDATE to INSERT ... ON CONFLICT
  DO UPDATE SET
    total_penalty_cents = EXCLUDED.total_penalty_cents;

  -- 8) Return result as JSON
  -- FIX: Changed from RETURN; to RETURN json_build_object(...)
  SELECT json_build_object(
    'date', p_date::text,
    'limit_minutes', v_limit_minutes,
    'used_minutes', p_used_minutes,
    'exceeded_minutes', v_exceeded_minutes,
    'penalty_cents', v_penalty_cents,
    'user_week_total_cents', v_user_week_total_cents,
    'pool_total_cents', v_pool_total_cents
  )
  INTO v_result;

  RETURN v_result;
END;
$function$
;

grant delete on table "public"."commitments" to "anon";

grant insert on table "public"."commitments" to "anon";

grant references on table "public"."commitments" to "anon";

grant select on table "public"."commitments" to "anon";

grant trigger on table "public"."commitments" to "anon";

grant truncate on table "public"."commitments" to "anon";

grant update on table "public"."commitments" to "anon";

grant delete on table "public"."commitments" to "authenticated";

grant insert on table "public"."commitments" to "authenticated";

grant references on table "public"."commitments" to "authenticated";

grant select on table "public"."commitments" to "authenticated";

grant trigger on table "public"."commitments" to "authenticated";

grant truncate on table "public"."commitments" to "authenticated";

grant update on table "public"."commitments" to "authenticated";

grant delete on table "public"."commitments" to "service_role";

grant insert on table "public"."commitments" to "service_role";

grant references on table "public"."commitments" to "service_role";

grant select on table "public"."commitments" to "service_role";

grant trigger on table "public"."commitments" to "service_role";

grant truncate on table "public"."commitments" to "service_role";

grant update on table "public"."commitments" to "service_role";

grant delete on table "public"."daily_usage" to "anon";

grant insert on table "public"."daily_usage" to "anon";

grant references on table "public"."daily_usage" to "anon";

grant select on table "public"."daily_usage" to "anon";

grant trigger on table "public"."daily_usage" to "anon";

grant truncate on table "public"."daily_usage" to "anon";

grant update on table "public"."daily_usage" to "anon";

grant delete on table "public"."daily_usage" to "authenticated";

grant insert on table "public"."daily_usage" to "authenticated";

grant references on table "public"."daily_usage" to "authenticated";

grant select on table "public"."daily_usage" to "authenticated";

grant trigger on table "public"."daily_usage" to "authenticated";

grant truncate on table "public"."daily_usage" to "authenticated";

grant update on table "public"."daily_usage" to "authenticated";

grant delete on table "public"."daily_usage" to "service_role";

grant insert on table "public"."daily_usage" to "service_role";

grant references on table "public"."daily_usage" to "service_role";

grant select on table "public"."daily_usage" to "service_role";

grant trigger on table "public"."daily_usage" to "service_role";

grant truncate on table "public"."daily_usage" to "service_role";

grant update on table "public"."daily_usage" to "service_role";

grant delete on table "public"."payments" to "anon";

grant insert on table "public"."payments" to "anon";

grant references on table "public"."payments" to "anon";

grant select on table "public"."payments" to "anon";

grant trigger on table "public"."payments" to "anon";

grant truncate on table "public"."payments" to "anon";

grant update on table "public"."payments" to "anon";

grant delete on table "public"."payments" to "authenticated";

grant insert on table "public"."payments" to "authenticated";

grant references on table "public"."payments" to "authenticated";

grant select on table "public"."payments" to "authenticated";

grant trigger on table "public"."payments" to "authenticated";

grant truncate on table "public"."payments" to "authenticated";

grant update on table "public"."payments" to "authenticated";

grant delete on table "public"."payments" to "service_role";

grant insert on table "public"."payments" to "service_role";

grant references on table "public"."payments" to "service_role";

grant select on table "public"."payments" to "service_role";

grant trigger on table "public"."payments" to "service_role";

grant truncate on table "public"."payments" to "service_role";

grant update on table "public"."payments" to "service_role";

grant delete on table "public"."usage_adjustments" to "anon";

grant insert on table "public"."usage_adjustments" to "anon";

grant references on table "public"."usage_adjustments" to "anon";

grant select on table "public"."usage_adjustments" to "anon";

grant trigger on table "public"."usage_adjustments" to "anon";

grant truncate on table "public"."usage_adjustments" to "anon";

grant update on table "public"."usage_adjustments" to "anon";

grant delete on table "public"."usage_adjustments" to "authenticated";

grant insert on table "public"."usage_adjustments" to "authenticated";

grant references on table "public"."usage_adjustments" to "authenticated";

grant select on table "public"."usage_adjustments" to "authenticated";

grant trigger on table "public"."usage_adjustments" to "authenticated";

grant truncate on table "public"."usage_adjustments" to "authenticated";

grant update on table "public"."usage_adjustments" to "authenticated";

grant delete on table "public"."usage_adjustments" to "service_role";

grant insert on table "public"."usage_adjustments" to "service_role";

grant references on table "public"."usage_adjustments" to "service_role";

grant select on table "public"."usage_adjustments" to "service_role";

grant trigger on table "public"."usage_adjustments" to "service_role";

grant truncate on table "public"."usage_adjustments" to "service_role";

grant update on table "public"."usage_adjustments" to "service_role";

grant delete on table "public"."user_week_penalties" to "anon";

grant insert on table "public"."user_week_penalties" to "anon";

grant references on table "public"."user_week_penalties" to "anon";

grant select on table "public"."user_week_penalties" to "anon";

grant trigger on table "public"."user_week_penalties" to "anon";

grant truncate on table "public"."user_week_penalties" to "anon";

grant update on table "public"."user_week_penalties" to "anon";

grant delete on table "public"."user_week_penalties" to "authenticated";

grant insert on table "public"."user_week_penalties" to "authenticated";

grant references on table "public"."user_week_penalties" to "authenticated";

grant select on table "public"."user_week_penalties" to "authenticated";

grant trigger on table "public"."user_week_penalties" to "authenticated";

grant truncate on table "public"."user_week_penalties" to "authenticated";

grant update on table "public"."user_week_penalties" to "authenticated";

grant delete on table "public"."user_week_penalties" to "service_role";

grant insert on table "public"."user_week_penalties" to "service_role";

grant references on table "public"."user_week_penalties" to "service_role";

grant select on table "public"."user_week_penalties" to "service_role";

grant trigger on table "public"."user_week_penalties" to "service_role";

grant truncate on table "public"."user_week_penalties" to "service_role";

grant update on table "public"."user_week_penalties" to "service_role";

grant delete on table "public"."users" to "anon";

grant insert on table "public"."users" to "anon";

grant references on table "public"."users" to "anon";

grant select on table "public"."users" to "anon";

grant trigger on table "public"."users" to "anon";

grant truncate on table "public"."users" to "anon";

grant update on table "public"."users" to "anon";

grant delete on table "public"."users" to "authenticated";

grant insert on table "public"."users" to "authenticated";

grant references on table "public"."users" to "authenticated";

grant select on table "public"."users" to "authenticated";

grant trigger on table "public"."users" to "authenticated";

grant truncate on table "public"."users" to "authenticated";

grant update on table "public"."users" to "authenticated";

grant delete on table "public"."users" to "service_role";

grant insert on table "public"."users" to "service_role";

grant references on table "public"."users" to "service_role";

grant select on table "public"."users" to "service_role";

grant trigger on table "public"."users" to "service_role";

grant truncate on table "public"."users" to "service_role";

grant update on table "public"."users" to "service_role";

grant delete on table "public"."weekly_pools" to "anon";

grant insert on table "public"."weekly_pools" to "anon";

grant references on table "public"."weekly_pools" to "anon";

grant select on table "public"."weekly_pools" to "anon";

grant trigger on table "public"."weekly_pools" to "anon";

grant truncate on table "public"."weekly_pools" to "anon";

grant update on table "public"."weekly_pools" to "anon";

grant delete on table "public"."weekly_pools" to "authenticated";

grant insert on table "public"."weekly_pools" to "authenticated";

grant references on table "public"."weekly_pools" to "authenticated";

grant select on table "public"."weekly_pools" to "authenticated";

grant trigger on table "public"."weekly_pools" to "authenticated";

grant truncate on table "public"."weekly_pools" to "authenticated";

grant update on table "public"."weekly_pools" to "authenticated";

grant delete on table "public"."weekly_pools" to "service_role";

grant insert on table "public"."weekly_pools" to "service_role";

grant references on table "public"."weekly_pools" to "service_role";

grant select on table "public"."weekly_pools" to "service_role";

grant trigger on table "public"."weekly_pools" to "service_role";

grant truncate on table "public"."weekly_pools" to "service_role";

grant update on table "public"."weekly_pools" to "service_role";


  create policy "Users can insert own commitments"
  on "public"."commitments"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can read own commitments"
  on "public"."commitments"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Users can update own commitments"
  on "public"."commitments"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "Users can insert own daily usage"
  on "public"."daily_usage"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can read own daily usage"
  on "public"."daily_usage"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Users can update own daily usage"
  on "public"."daily_usage"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "Users can read own payments"
  on "public"."payments"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Users can read own adjustments"
  on "public"."usage_adjustments"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Users can read own penalties"
  on "public"."user_week_penalties"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Users can read own data"
  on "public"."users"
  as permissive
  for select
  to public
using ((auth.uid() = id));



  create policy "Users can update own data"
  on "public"."users"
  as permissive
  for update
  to public
using ((auth.uid() = id));



  create policy "Users can read weekly pools"
  on "public"."weekly_pools"
  as permissive
  for select
  to public
using ((auth.uid() IS NOT NULL));


CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


